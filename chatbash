#!/bin/bash# Load API key from environment variable
API_KEY="$OPENAI_API_KEY"
MODEL="gpt-4"# You can use "gpt-3.5-turbo" if you prefer# Function to check if required dependencies are installedcheck_dependencies() {
    local dependencies=("curl""jq")
    local missing_dependencies=()

    for dep in"${dependencies[@]}"; doif ! command -v $dep &> /dev/null; then
            missing_dependencies+=("$dep")
        fidoneif [ ${#missing_dependencies[@]} -ne 0 ]; thenecho"The following dependencies are missing:"for dep in"${missing_dependencies[@]}"; doecho"  - $dep"done# Ask the user if they want to install the missing dependenciesread -p "Do you want to install the missing dependencies? (yes/no): " install_confirm
        if [[ "$install_confirm" == "yes" ]]; thenfor dep in"${missing_dependencies[@]}"; doecho"Installing $dep..."
                sudo apt-get install -y $depif [[ $? -ne 0 ]]; thenecho"Failed to install $dep. Please install it manually and rerun the script."exit 1
                fidoneelseecho"Please install the missing dependencies and run the script again."exit 1
        fifi
}

# Function to call the OpenAI APIget_chatgpt_response() {
    local prompt=$1local response=$(curl -s https://api.openai.com/v1/chat/completions \
        -H "Content-Type: application/json" \
        -H "Authorization: Bearer $API_KEY" \
        -d '{
          "model": "'"$MODEL"'",
          "messages": [{"role": "user", "content": "'"$prompt"'"}]
        }')
    
    # Check for errors in API responseif [[ $(echo"$response" | jq -r '.error') != "null" ]]; thenecho"Error in API request: $(echo "$response" | jq -r '.error.message')"exit 1
    fi# Extract the response content using jqecho"$response" | jq -r '.choices[0].message.content'
}

# Function to check for dangerous commandsis_dangerous_command() {
    localcommand="$1"# List of dangerous patternslocal dangerous_patterns=(
        "rm -rf""mkfs""dd if""fdisk""parted""mklabel""mkpart""wipefs"
    )

    # Check if the command contains any dangerous patternfor pattern in"${dangerous_patterns[@]}"; doif [[ "$command" == *"$pattern"* ]]; thenecho"dangerous"returnfidoneecho"safe"
}

# Function to execute commandsexecute_commands() {
    local commands="$1"echo -e "Commands to be executed:\n$commands"# Confirm with the userread -p "Do you want to execute these commands? (yes/no): " confirm
    if [[ "$confirm" == "yes" ]]; thenecho -e "\nExecuting commands..."while IFS= read -r cmd; do# Ensure each line is a command and exclude lines starting with ```if [[ -n "$cmd" ]] && [[ "$cmd" != *"#"* ]] && [[ "$cmd" != \`\`\`* ]]; then# Ignore comments and backticksif [[ $(is_dangerous_command "$cmd") == "dangerous" ]]; thenecho"Warning: The command '$cmd' is potentially destructive and will not be executed."elseecho"Running: $cmd"eval"$cmd"
                    status=$?
                    if [[ $status -ne 0 ]]; thenecho"Error: Command '$cmd' failed with status $status."echo"Execution will continue with the next command."# Uncomment the next line if you want to stop execution on error# exit 1fififidone <<< "$commands"elseecho"Command execution aborted."fi
}

# Main script logic# Check for dependencies before running the rest of the script
check_dependencies

# Check if any command-line arguments were providedif [ $# -gt 0]; then# Join all command-line arguments into a single string
    description="$*"elseecho"Describe what you want to accomplish:"read description
fi# Get suggested commands from ChatGPT
prompt="Given the description: '$description', please provide only the exact shell commands without any explanation, description, or comments."
chatgpt_output=$(get_chatgpt_response "$prompt")

# Show the suggested commands and ask for confirmation
execute_commands "$chatgpt_output"
